let marvinInsertModule = function() {
	
	//#region CONSTs

	const FRAGMENT_SIDE_PADDING = 5;
	const FRAGMENT_BOTTOM_PADDING = 5;
	const EMPTY_MRV = "<cml><MDocument></MDocument></cml>";
	const ARROW_MRV = '<cml xmlns="http://www.chemaxon.com" version="ChemAxon file format v20.9.0, generated by vunknown" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.chemaxon.com http://www.chemaxon.com/marvin/schema/mrvSchema_20_9_0.xsd"><MDocument><MChemicalStruct><reaction><molecule molID="m1" title="justanarrow.cdx"><atomArray/><bondArray/></molecule></reaction></MChemicalStruct><MPolyline headLength="0.6" headWidth="0.4" id="o1"><MPoint x="6.0337" y="-17.2998"/><MPoint x="23.0723" y="-17.2998"/></MPolyline></MDocument></cml>';
	
	////#endregion

	/**
	 * Inserts fragmentXMLStr into mainMRVStr based on the given position.
	 * @param {string} loc Where fragmentXMLStr should go.
	 * @param {string} fragmentXMLStr The fragment MRV to insert.
	 * @param {string} mainMRVStr The base MRV to insert into.
	 */
	let insertFragmentMarvin = function(loc, fragmentXMLStr, mainMRVStr) {
		return new Promise(function(resolve, reject) {
			convertToMRV(fragmentXMLStr).then(function(newFragmentMRVStr) {
				if ([null, "", undefined, EMPTY_MRV].includes(mainMRVStr)) {
					mainMRVStr = ARROW_MRV;
				}
			
				let mainMRV = loadXML(mainMRVStr);

				// Check the newFragmentMRVStr to see if its a blank CML.
				// If it is, resolve out and terminate, we can't insert this.
				let fragmentXML = loadXML(newFragmentMRVStr);
				let fragmentMDoc = fragmentXML.getElementsByTagName("MDocument")[0];
				if (fragmentMDoc.children.length == 0) {
					resolve({"status": "Error", "data": "Cannot insert blank structure into reaction."});
					return;
				}
		
				// We need to figure out if we have an arrow.
				let arrowFragCol = mainMRV.getElementsByTagName("MPolyline");
				let hasArrow = arrowFragCol.length > 0;
				if (!hasArrow) {
					arrowFragCol = mainMRV.getElementsByTagName("arrow");
					hasArrow = arrowFragCol.length > 0;
				}

				// If we do have one, then we'll set up this var as a promise that resolves with the mainMRVStr.
				let noArrowPromise = new Promise(function(resolve, reject) {resolve({"reactionData": mainMRVStr})}); 

				// Otherwise, we need to insert this the current MRV fragment into a reaction, so we'll run it through this
				// function using the ARROW_MRV as a base.
				if (!hasArrow) {
					noArrowPromise = insertFragmentMarvin(loc, mainMRVStr, ARROW_MRV);
				}

				// Then when we finish the promise, figure out where the structure we're trying to insert belongs.
				noArrowPromise.then(function(arrowPromiseRes) {
					mainMRV = loadXML(arrowPromiseRes["reactionData"]);
					let mainChemStruct = mainMRV.getElementsByTagName("MChemicalStruct")[0];
					let numMols = mainChemStruct.getElementsByTagName("molecule").length;
					let currMolNum = numMols + 1;
					let newFragmentId = currMolNum * 1000;

					let defaultX = 0;
					let defaultY = 0;
				
					let reactionElement = mainChemStruct.getElementsByTagName("reaction")[0];
					let typeList = "reactantList";
					let molListCol;
					let molList = createXMLDoc(typeList);
			
					if (loc == "left") {
						// Reactant logic.
						molListCol = reactionElement.getElementsByTagName(typeList);
						if (molListCol.length > 0) {
							molList = molListCol[0];
						}
						
						defaultX = getLeftmostArrowX(arrowFragCol[0]) - FRAGMENT_SIDE_PADDING;
						defaultY = getArrowY(arrowFragCol[0]);
			
					} else if (loc == "top") {
						// Reagents go here.
						typeList = "agentList";
						molListCol = reactionElement.getElementsByTagName(typeList);
						if (molListCol.length > 0) {
							molList = molListCol[0];
						} else {
							molList = createXMLDoc(typeList);
						}
						
						defaultX = getArrowXCenter(arrowFragCol[0]);
						defaultY = getArrowY(arrowFragCol[0]) + FRAGMENT_BOTTOM_PADDING;
			
					} else if (loc == "bottom") {
						// Solvents would go here, but MRV doesn't seem to support them so I'm leaving a spot here for them.
						typeList = "agentList";
						molListCol = reactionElement.getElementsByTagName(typeList);
						if (molListCol.length > 0) {
							molList = molListCol[0];
						} else {
							molList = createXMLDoc(typeList);
						}
						
						defaultX = getArrowXCenter(arrowFragCol[0]);
						defaultY = getArrowY(arrowFragCol[0]) - FRAGMENT_BOTTOM_PADDING;
					}
				
					let newFragmentCML = loadXML(newFragmentMRVStr);
					let newFragmentMol = newFragmentCML.getElementsByTagName("molecule")[0];
					let newFragmentAtomArray = newFragmentMol.getElementsByTagName("atomArray")[0];
					let normalizedNewFrag = normalizeAtom(newFragmentAtomArray);
					newFragmentMol.removeChild(newFragmentAtomArray);
					newFragmentMol.appendChild(normalizedNewFrag);
					let newMolList = addToMolList(molList, newFragmentMol, currMolNum, defaultX, defaultY, typeList);
	
					if (loc != "left") {
						adjustArrow(arrowFragCol[0], newMolList, mainMRV);
					}
	
					if (molListCol.length > 0) {
						reactionElement.removeChild(molList);
					}
					reactionElement.appendChild(newMolList);
			
					// Make absolutely sure the xmlns attribute isn't on anything in this string.
					let xmlnsRe = /xmlns=\"\"/g;
					let finalMRVStr = xmlToString(mainMRV);
					finalMRVStr = finalMRVStr.replace(xmlnsRe, "");
	
					updateLiveEditStructureData("mycdx", finalMRVStr, "MRV").then(function() {
						resolve({
							'fragmentId':newFragmentId,
							'reactionData':xmlToString(mainMRV),
							'reactionFormat':'MRV',
							'reactionElement':'mycdx'
						});
					});
				});
			});
			return;
		});
	}

	/**
	 * Adds newMol to molList after figuring out what position on the grid it and the other members of molList belong.
	 * @param {HTMLCollection} molList The list of molecules to offset and insert newMol into.
	 * @param {HTMLCollection} newMol The molecule to insert into molList.
	 * @param {number} molNum The number of this molecule for the molId attr.
	 * @param {number} defaultX The default X position for newMol.
	 * @param {number} defaultY The default Y position for newMol.
	 */
	let addToMolList = function(molList, newMol, molNum, defaultX, defaultY) {
		// Set the ID of the new molecule.
		newMol.setAttribute("molID", "m" + molNum);

		// Figure out the width of it and include that in the X offset.
		let newMolWidth = getWidthOfMrvFrag(newMol);
		let molXOffset = FRAGMENT_SIDE_PADDING + newMolWidth;

		// Instantiate the Y coordinate as the default.
		let molY = defaultY;

		let molElements = molList.getElementsByTagName("molecule");
		molElements = offsetMolXPositions(molElements, molXOffset);

		// Figure out the rightmost coordinate.
		let molCoordsList = getAtomCoordsList(molList, "x2");
		let rightMostCoord = molCoordsList.max();

		// If we don't have a coordinate, then we want the inserted molecule to be left of wherever the default X coordinate is.
		// Otherwise, place it to the right of the rightmost coordinate.
		let newMolXPos = isNaN(rightMostCoord) || [Infinity, -Infinity].includes(rightMostCoord) ? 
			defaultX : 
			rightMostCoord + FRAGMENT_SIDE_PADDING;

		// Now move the molecule and append it to the list.
		moveAtomToNewCenter(newMol, newMolXPos, molY);
		molList.appendChild(newMol);
		return molList;
	}

	/**
	 * Helper function to offset the X positions of all of the molecules in molElements.
	 * @param {HTMLCollection} molElements The collection of molecules to offset.
	 * @param {number} xOffset The distance to offset each molecule by.
	 */
	let offsetMolXPositions = function(molElements, xOffset) {

		// If we have any molecules to iterate through...
		for (let i=0; i < molElements.length; ++i) {
			// Grab each one, expand out each atom if necessary...
			let mol = molElements[i];
			let molAtomArray = mol.getElementsByTagName("atomArray")[0];
			let normalizedAtomArray = normalizeAtom(molAtomArray);

			// Figure out the center of each fragment...
			let molCenter = getCenterOfMrvFrag(normalizedAtomArray);
			let molX = molCenter["xPos"];

			// Re-set molY to match the yPos of whatever's in this list. We want each line to roughly be aligned.
			molY = molCenter["yPos"];

			// Move the molecule horizontally by the offset. We want to preserve the vertical coordinate.
			moveAtomToNewCenter(normalizedAtomArray, molX - xOffset, molY);

			// Now replace the original atomArray element in this molecule with the one we just modified.
			mol.removeChild(molAtomArray);
			mol.appendChild(normalizedAtomArray);
		}

		return molElements;
	}

	/**
	 * Determines if the reaction arrow needs to be extended, displacing reactants if necessary.
	 * @param {HTMLCollection} arrowFrag The arrow fragment.
	 * @param {HTMLCollection} molList The list of mols to check the leftmost X coord of.
	 * @param {HTMLCollection} mainMRV The base MRV. 
	 */
	let adjustArrow = function(arrowFrag, molList, mainMRV) {
		let arrowLeftX = getLeftmostArrowX(arrowFrag);
		let molXCoordsList = getAtomCoordsList(molList, "x2");
		let leftMostAtomPos = molXCoordsList.min();
	
		// Check if the leftmost part of the arrow is further right than the leftmost item in molList.
		// If it is, then extend the arrow's endpoint left.
		if (arrowLeftX > leftMostAtomPos) {

			// Figure out how much further the arrow needs to be extended;
			// currently using the difference between the left points, added to the fragment side padding.
			let diff = arrowLeftX - leftMostAtomPos;
			let xOffset = diff + FRAGMENT_SIDE_PADDING;
			if (arrowFrag.tagName == "arrow") {
				adjustArrowForArrowTag(arrowFrag, xOffset);
			} else {
				adjustArrowForMPolyline(arrowFrag, xOffset);
			}
	
			// Now check if we have any reactants to move.
			let reactantsCol = mainMRV.getElementsByTagName("reactantList");
			if (reactantsCol.length) {
				let reactantsElem = reactantsCol[0];
				let reactantsMols = reactantsElem.getElementsByTagName("molecule");
				offsetMolXPositions(reactantsMols, xOffset);
			}
		}
	}
	
	/**
	 * Extends the arrow by offset amount for the arrow fragments that have the arrow tagname.
	 * @param {HTMLCollection} arrowFrag The arrow to extend.
	 * @param {number} offset How far the endpoint should be moved.
	 */
	let adjustArrowForArrowTag = function(arrowFrag, offset) {
		let x1 = parseFloat(arrowFrag.getAttribute("x1"));
		let x2 = parseFloat(arrowFrag.getAttribute("x2"));

		// Figure out which coordinate to adjust. We want the one that's smaller.
		if (x1 > x2) {
			arrowFrag.setAttribute("x2", x2 - offset);
		} else {
			arrowFrag.setAttribute("x1", x1 - offset);
		}
	}

	/**
	 * Extends the arrow by offset amount for the arrow fragments that have the MPolyline tag.
	 * @param {HTMLCollection} arrowFrag The arrow to extend.
	 * @param {number} offset How far the endpoint should be moved.
	 */
	let adjustArrowForMPolyline = function(arrowFrag, offset) {
		// Stub method. I'm not sure this is totally necessary because as far as I've seen,
		// the marvin spec doesn't have MPolyline arrows for reaction tags.
	}

	/**
	 * Calculate the width of the given structure by finding the difference between the left most and right most coordinates.
	 * @param {document} fragmentCML The marvin structure to insert.
	 */
	let getWidthOfMrvFrag = function(fragmentCML) {
		let xCoordsList = getAtomCoordsList(fragmentCML, "x2");
		let xMax = xCoordsList.max();
		let xMin = xCoordsList.min();

		return getDistOfMarvCoords(xMax, xMin);
	}

	/**
	 * Calculate the height of the given structure by finding the difference between the top most and bottom most coordinates.
	 * @param {document} fragmentCML The marvin structure to insert.
	 */
	let getHeightOfMrvFrag = function(fragmentCML) {
		let yCoordsList = getAtomCoordsList(fragmentCML, "y2");
		let yMax = yCoordsList.max();
		let yMin = yCoordsList.min();

		return getDistOfMarvCoords(yMax, yMin);
	}

	/**
	 * Calculates the center of the fragment by calculating the height and width and finding the exact centerpoint of both.
	 * @param {document} fragmentCML The marvin structure to insert.
	 */
	let getCenterOfMrvFrag = function(fragmentCML) {
		let width = getWidthOfMrvFrag(fragmentCML);
		let height = getHeightOfMrvFrag(fragmentCML);
		let xMax = getAtomCoordsList(fragmentCML, "x2").max();
		let yMax = getAtomCoordsList(fragmentCML, "y2").max();

		return {
			xPos: xMax - (width/2),
			yPos: yMax - (height/2),
		};
	}

	/**
	 * Iterates through all of the atoms in the fragmentCML and calculates the difference in x and y from the center for each.
	 * @param {document} fragmentCML The structure to calculate distances from.
	 */
	let getAtomDiffListFromCenter = function(fragmentCML) {
		let atomCollection = fragmentCML.getElementsByTagName("atom");
		let atomList = [].slice.call(atomCollection);
		let center = getCenterOfMrvFrag(fragmentCML);

		let returnObj = {};
		atomList.map(function(atom) {
			let atomId = atom.getAttribute("id");
			let atomDiffs = getAtomDiffFromCenter(atom, center);
			returnObj[atomId] = atomDiffs;
		});
		
		return returnObj;
	}

	/**
	 * Calculates the difference in coordinates for a single atom from the center of the molecule.
	 * @param {document} atom The atom to calculate the difference from center with.
	 * @param {JSON} center The coordinates of the center of the molecule.
	 */
	let getAtomDiffFromCenter = function(atom, center) {
		let atomX = parseFloat(atom.getAttribute("x2"));
		let atomY = parseFloat(atom.getAttribute("y2"));

		return {
			xDelta: atomX - center.xPos,
			yDelta: atomY - center.yPos,
		};
	}

	/**
	 * Adjusts the X and Y positions of the atoms in the given fragment to move the structure to the new center
	 * point defined by (newX, newY).
	 * @param {document} fragmentCML The structure to reposition.
	 * @param {number} newX The new X position.
	 * @param {number} newY The new Y position.
	 */
	let moveAtomToNewCenter = function(fragmentCML, newX, newY) {
		let atomCollection = fragmentCML.getElementsByTagName("atom");
		let atomDiffsFromCenter = getAtomDiffListFromCenter(fragmentCML);
		
		for (let i=0; i < atomCollection.length; ++i) {
			let atom = atomCollection[i];
			let atomId = atom.getAttribute("id");
			atom.setAttribute("x2", atomDiffsFromCenter[atomId]["xDelta"] + newX);
			atom.setAttribute("y2", atomDiffsFromCenter[atomId]["yDelta"] + newY);
		}

		return fragmentCML;
	}

	/**
	 * Get the leftmost x coordinate of the given arrow fragment.
	 * @param {HTMLCollection} fragmentCML The arrow fragment.
	 */
	let getLeftmostArrowX = function(fragmentCML) {
		return fragmentCML.tagName == "arrow" ?
			getLeftmostArrowXFromArrow(fragmentCML):
			getLeftmostArrowXFromMPolyline(fragmentCML);
	}

	/**
	 * Helper function for the above to calculate the x coordinate for <arrow> items.
	 * @param {HTMLCollection} fragmentCML The arrow fragment.
	 */
	let getLeftmostArrowXFromArrow = function(fragmentCML) {
		let x1 = parseFloat(fragmentCML.getAttribute("x1"));
		let x2 = parseFloat(fragmentCML.getAttribute("x2"));
		return Math.min(x1, x2);
	}

	/**
	 * Helper function for the above to calculate the x coordinate for <MPolyline> items.
	 * @param {HTMLCollection} fragmentCML The arrow fragment.
	 */
	let getLeftmostArrowXFromMPolyline = function(fragmentCML) {
		let xCoordsList = getCoordsList(fragmentCML, "MPoint", "x");
		let xMin = xCoordsList.min();

		return isNaN(xMin) ? 0 : xMin;
	}

	/**
	 * Calculates the horizontal centerpoint of an arrow fragment.
	 * @param {HTMLCollection} fragmentCML The arrow fragment.
	 */
	let getArrowXCenter = function(fragmentCML) {
		return fragmentCML.tagName == "arrow" ?
			getArrowXCenterFromArrow(fragmentCML):
			getArrowXCenterFromMPolyline(fragmentCML);
	}

	/**
	 * Helper function for the above to calculate the x coordinate for <arrow> items.
	 * @param {HTMLCollection} fragmentCML The arrow fragment.
	 */
	let getArrowXCenterFromArrow = function(fragmentCML) {
		let x1 = parseFloat(fragmentCML.getAttribute("x1"));
		let x2 = parseFloat(fragmentCML.getAttribute("x2"));

		if (isNaN(x1) && !isNaN(x2)) {
			return x2;
		} else if (isNaN(x2) && !isNaN(x1)) {
			return x1;
		} else {
			return (x1 + x2) / 2;
		}
	}

	/**
	 * Helper function for the above to calculate the x coordinate for <MPolyline> items.
	 * @param {HTMLCollection} fragmentCML The arrow fragment.
	 */
	let getArrowXCenterFromMPolyline = function(fragmentCML) {
		let xCoordsList = getCoordsList(fragmentCML, "MPoint", "x");
		let xMin = xCoordsList.min();
		let xMax = xCoordsList.max();

		return isNaN(xMin) ? 0 : (xMin + xMax) / 2;
	}

	/**
	 * Calculates the vertical center of the reaction arrow.
	 * @param {document} fragmentCML The reaction to get the vertical center of the arrow from..
	 */
	let getArrowY = function(fragmentCML) {
		return fragmentCML.tagName == "arrow" ?
			getArrowYFromArrow(fragmentCML):
			getArrowYFromMPolyline(fragmentCML);
	}

	/**
	 * Helper function for the above to calculate the center Y coordinate for <arrow> items.
	 * @param {HTMLCollection} fragmentCML The arrow fragment.
	 */
	let getArrowYFromArrow = function(fragmentCML) {
		let y1 = parseFloat(fragmentCML.getAttribute("y1"));
		let y2 = parseFloat(fragmentCML.getAttribute("y2"));

		if (isNaN(y1) && !isNaN(y2)) {
			return y2;
		} else if (isNaN(y2) && !isNaN(y1)) {
			return y1;
		} else {
			return (y1 + y2) / 2;
		}
	}

	/**
	 * Helper function for the above to calculate the center Y coordinate for <MPolyline> items.
	 * @param {HTMLCollection} fragmentCML The arrow fragment.
	 */
	let getArrowYFromMPolyline = function(fragmentCML) {
		let yCoordsList = getCoordsList(fragmentCML, "MPoint", "y");
		let yMax = yCoordsList.max();
		let yMin = yCoordsList.min();
		
		// This is a straight line.
		if (yMax == yMin) {
			return yMax;
		} else {
			let height = (yMax - yMin);
			if (yMin > 0 || yMax < 0) {
				return height / 2;
			} else {
				return yMax - (height / 2);
			}
		}
	}

	/**
	 * Helper function to get all of the atom coordinates of a given dimension for a structure.
	 * @param {document} fragmentCML The structure to get coordinates from.
	 * @param {string} coordName The name of the attribute holding the cooordinate.
	 */
	let getAtomCoordsList = function(fragmentCML, coordName) {
		return getCoordsList(fragmentCML, "atom", coordName);
	}

	/**
	 * Helper function to get all of the coordinates of a given tag name, of a given dimension for a structure.
	 * @param {document} fragmentCML The structure to get coordinates from.
	 * @param {string} tagName The name of the XML tag to get elements by.
	 * @param {string} coordName The name of the attribute holding the cooordinate.
	 */
	let getCoordsList = function(fragmentCML, tagName, coordName) {
		let tagCollection = fragmentCML.getElementsByTagName(tagName);
		let tagList = [].slice.call(tagCollection); // Can't use .map on an HTMLCollection and I can't use a spread operator because this might be used in IE...
		let coordsList = tagList.map(function(tag) { return parseFloat(tag.getAttribute(coordName)); });

		return coordsList;
	}

	/**
	 * Calculates the distance between the two given coordinates, assuming that there is only a straight line between the two points.
	 * (Either the points are on the same X-plane or the same Y-plane)
	 * @param {number} maxCoord The larger of the coordinates to calculate distance from.
	 * @param {number} minCoord The smaller of the coordinates to calculate distance from.
	 */
	let getDistOfMarvCoords = function(maxCoord, minCoord) {
		// If both coords are positive or if they're both negative, then subtract the min from the max.
		// Otherwise, reverse the positiviy of the min and add the two.
		if (minCoord > 0 || maxCoord < 0) {
			return maxCoord - minCoord;
		} else {
			return maxCoord + -minCoord;
		}
	}

	/**
	 * Helper function to expand an <atomArray>. Some <atomArray> elements, particularly the ones
	 * returned from JChem, are condensed so that all of the atoms are stored directly in the attributes
	 * of the <atomArray> instead of being discrete <atom> nodes that are children of the <atomArray>
	 * @param {HTMLCollection} atomArrayCML The atom array HTML element to normalize.
	 */
	let normalizeAtom = function(atomArrayCML) {
		// Expand the condensed atom array if we see the atomID attribute on the atomArrayCML.
		if (atomArrayCML.hasAttribute("atomID")) {
			atomArrayCML = expandCondensedAtomArray(atomArrayCML);
		}

		return atomArrayCML;
	}

	/**
	 * Helper function for the above that breaks down the attributes on the atomArray and creates
	 * discrete <atom> nodes with that data.
	 * @param {HTMLCollection} atomArrayCML 
	 */
	let expandCondensedAtomArray = function(atomArrayCML) {
		let atomIdsAttr = atomArrayCML.getAttribute("atomID");
		let atomIdsList = atomIdsAttr.split(" ");

		let elementsAttr = atomArrayCML.getAttribute("elementType");
		let elementsList = elementsAttr.split(" ");

		let xAttr = atomArrayCML.getAttribute("x2");
		let xList = xAttr.split(" ");

		let yAttr = atomArrayCML.getAttribute("y2");
		let yList = yAttr.split(" ");

		let atomArray = createXMLDoc("atomArray");
		for (let i=0; i < atomIdsList.length; ++i) {
			let atomId = atomIdsList[i];
			let elementType = elementsList[i];
			let x = xList[i];
			let y = yList[i];
			atomArray.appendChild(createAtom(atomId, elementType, x, y));
		}

		return atomArray;
	}

	/**
	 * Helper function to create an <atom> object.
	 * @param {string} id The atom's ID.
	 * @param {string} elementType The atom's element.
	 * @param {string} x The atom's X coordinate.
	 * @param {string} y The atom's Y coordinate.
	 */
	let createAtom = function(id, elementType, x, y) {
		let atom = createXMLDoc("atom");
		atom.setAttribute("id", id);
		atom.setAttribute("elementType", elementType);
		atom.setAttribute("x2", x);
		atom.setAttribute("y2", y);

		return atom;
	}

	/**
	 * Helper function to create an XML document object that we can use JS to interact with.
	 * @param {string} tagname The tagname of the element to create.
	 */
	let createXMLDoc = function(tagname) {
		let parser = new DOMParser();
		let XML = parser.parseFromString("<" + tagname + " />", "text/xml");
		return XML.getElementsByTagName(tagname)[0];
	}

	return {
		insertFragmentMarvin: insertFragmentMarvin,
	};
};

marvinInsert = marvinInsertModule();
